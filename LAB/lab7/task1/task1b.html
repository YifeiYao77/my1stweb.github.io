<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task 1b: Recursive Subdivision Sphere with Phong Lighting</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            flex-direction: row;
            max-width: 1200px;
            margin: 0 auto;
        }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            border: 1px solid #333;
            background-color: #000;
        }
        .controls {
            width: 300px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .range-value {
            font-size: 0.8em;
            color: #666;
            text-align: right;
        }
        .toggle-group {
            display: flex;
            margin-bottom: 10px;
        }
        .toggle {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .toggle input {
            margin-right: 5px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #45a049;
        }
        h1, h2 {
            margin-top: 0;
            color: #333;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Task 1b: Recursive Subdivision Sphere with Phong Lighting</h1>

    <div class="container">
        <div class="canvas-container">
            <canvas id="gl-canvas" width="800" height="600"></canvas>
        </div>

        <div class="controls">
            <h2>Lighting Controls</h2>

            <div class="control-group toggle-group">
                <div class="toggle">
                    <input type="checkbox" id="ambient-toggle" checked>
                    <label for="ambient-toggle">Ambient</label>
                </div>
                <div class="toggle">
                    <input type="checkbox" id="diffuse-toggle" checked>
                    <label for="diffuse-toggle">Diffuse</label>
                </div>
                <div class="toggle">
                    <input type="checkbox" id="specular-toggle" checked>
                    <label for="specular-toggle">Specular</label>
                </div>
            </div>

            <div class="control-group">
                <label for="light-x">Light Position X</label>
                <input type="range" id="light-x" min="-5" max="5" step="0.1" value="2">
                <div class="range-value" id="light-x-value">2.0</div>
            </div>

            <div class="control-group">
                <label for="light-y">Light Position Y</label>
                <input type="range" id="light-y" min="-5" max="5" step="0.1" value="2">
                <div class="range-value" id="light-y-value">2.0</div>
            </div>

            <div class="control-group">
                <label for="light-z">Light Position Z</label>
                <input type="range" id="light-z" min="-5" max="5" step="0.1" value="2">
                <div class="range-value" id="light-z-value">2.0</div>
            </div>

            <div class="control-group">
                <label for="ambient-intensity">Ambient Intensity</label>
                <input type="range" id="ambient-intensity" min="0" max="1" step="0.01" value="0.2">
                <div class="range-value" id="ambient-intensity-value">0.20</div>
            </div>

            <div class="control-group">
                <label for="diffuse-coefficient">Diffuse Coefficient</label>
                <input type="range" id="diffuse-coefficient" min="0" max="1" step="0.01" value="0.8">
                <div class="range-value" id="diffuse-coefficient-value">0.80</div>
            </div>

            <div class="control-group">
                <label for="specular-coefficient">Specular Coefficient</label>
                <input type="range" id="specular-coefficient" min="0" max="1" step="0.01" value="0.5">
                <div class="range-value" id="specular-coefficient-value">0.50</div>
            </div>

            <div class="control-group">
                <label for="shininess">Shininess</label>
                <input type="range" id="shininess" min="1" max="128" step="1" value="32">
                <div class="range-value" id="shininess-value">32</div>
            </div>

            <div class="control-group">
                <label for="ambient-color">Ambient Color</label>
                <input type="color" id="ambient-color" value="#ffffff">
            </div>

            <div class="control-group">
                <label for="diffuse-color">Diffuse Color</label>
                <input type="color" id="diffuse-color" value="#ffffff">
            </div>

            <div class="control-group">
                <label for="specular-color">Specular Color</label>
                <input type="color" id="specular-color" value="#ffffff">
            </div>

            <div class="control-group">
                <label for="subdivision-depth">Subdivision Depth</label>
                <input type="range" id="subdivision-depth" min="1" max="5" step="1" value="3" disabled>
                <div class="range-value" id="subdivision-depth-value">3</div>
            </div>

            <button id="reset-button">Reset Light Position</button>
        </div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec3 aNormal;

        uniform mat4 uProjectionMatrix;
        uniform mat4 uModelViewMatrix;
        uniform mat3 uNormalMatrix;

        varying vec3 vNormal;
        varying vec3 vPosition;

        void main() {
            vec4 positionView = uModelViewMatrix * vec4(aPosition, 1.0);
            vPosition = positionView.xyz;

            vNormal = normalize(uNormalMatrix * aNormal);

            gl_Position = uProjectionMatrix * positionView;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        // Material properties
        uniform vec3 uMaterialAmbient;
        uniform vec3 uMaterialDiffuse;
        uniform vec3 uMaterialSpecular;
        uniform float uMaterialShininess;

        // Light properties
        uniform vec3 uLightPosition;
        uniform vec3 uLightAmbient;
        uniform vec3 uLightDiffuse;
        uniform vec3 uLightSpecular;

        // Lighting toggles
        uniform bool uUseAmbient;
        uniform bool uUseDiffuse;
        uniform bool uUseSpecular;

        // Interpolated values from vertex shader
        varying vec3 vNormal;
        varying vec3 vPosition;

        void main() {
            vec3 N = normalize(vNormal);
            vec3 L = normalize(uLightPosition - vPosition);
            vec3 V = normalize(-vPosition);
            vec3 R = reflect(-L, N);

            vec3 finalColor = vec3(0.0);

            // Ambient component
            if (uUseAmbient) {
                vec3 ambient = uMaterialAmbient * uLightAmbient;
                finalColor += ambient;
            }

            // Diffuse component
            if (uUseDiffuse) {
                float NdotL = max(dot(N, L), 0.0);
                vec3 diffuse = uMaterialDiffuse * NdotL * uLightDiffuse;
                finalColor += diffuse;
            }

            // Specular component
            if (uUseSpecular) {
                float RdotV = max(dot(R, V), 0.0);
                vec3 specular = uMaterialSpecular * pow(RdotV, uMaterialShininess) * uLightSpecular;
                finalColor += specular;
            }

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // WebGL context and resources
        let gl;
        let shaderProgram;
        let sphereVertexBuffer;
        let sphereNormalBuffer;
        let sphereIndexBuffer;
        let indexCount;

        // Uniform locations
        let uProjectionMatrix;
        let uModelViewMatrix;
        let uNormalMatrix;
        let uMaterialAmbient;
        let uMaterialDiffuse;
        let uMaterialSpecular;
        let uMaterialShininess;
        let uLightPosition;
        let uLightAmbient;
        let uLightDiffuse;
        let uLightSpecular;
        let uUseAmbient;
        let uUseDiffuse;
        let uUseSpecular;

        // Light properties
        let lightPosition = [2.0, 2.0, 2.0];
        let ambientIntensity = 0.2;
        let diffuseCoefficient = 0.8;
        let specularCoefficient = 0.5;
        let shininess = 32.0;

        // Material properties
        const materialAmbient = [1.0, 1.0, 1.0];
        const materialDiffuse = [1.0, 1.0, 1.0];
        const materialSpecular = [1.0, 1.0, 1.0];

        // Light colors
        let lightAmbient = [1.0, 1.0, 1.0];
        let lightDiffuse = [1.0, 1.0, 1.0];
        let lightSpecular = [1.0, 1.0, 1.0];

        // Camera parameters
        let cameraDistance = 5.0;
        let cameraAngleX = 0.0;
        let cameraAngleY = 0.0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Subdivision parameters
        const SUBDIVISION_DEPTH = 3;

        // Initialize WebGL
        function initWebGL() {
            const canvas = document.getElementById('gl-canvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                alert('WebGL not supported!');
                return;
            }

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        // Create and compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Initialize shaders
        function initShaders() {
            const vertexShaderSource = document.getElementById('vertex-shader').text;
            const fragmentShaderSource = document.getElementById('fragment-shader').text;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize shader program:', gl.getProgramInfoLog(shaderProgram));
                return;
            }

            gl.useProgram(shaderProgram);

            // Get attribute locations
            shaderProgram.aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
            gl.enableVertexAttribArray(shaderProgram.aPosition);

            shaderProgram.aNormal = gl.getAttribLocation(shaderProgram, 'aNormal');
            gl.enableVertexAttribArray(shaderProgram.aNormal);

            // Get uniform locations
            uProjectionMatrix = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
            uModelViewMatrix = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
            uNormalMatrix = gl.getUniformLocation(shaderProgram, 'uNormalMatrix');
            uMaterialAmbient = gl.getUniformLocation(shaderProgram, 'uMaterialAmbient');
            uMaterialDiffuse = gl.getUniformLocation(shaderProgram, 'uMaterialDiffuse');
            uMaterialSpecular = gl.getUniformLocation(shaderProgram, 'uMaterialSpecular');
            uMaterialShininess = gl.getUniformLocation(shaderProgram, 'uMaterialShininess');
            uLightPosition = gl.getUniformLocation(shaderProgram, 'uLightPosition');
            uLightAmbient = gl.getUniformLocation(shaderProgram, 'uLightAmbient');
            uLightDiffuse = gl.getUniformLocation(shaderProgram, 'uLightDiffuse');
            uLightSpecular = gl.getUniformLocation(shaderProgram, 'uLightSpecular');
            uUseAmbient = gl.getUniformLocation(shaderProgram, 'uUseAmbient');
            uUseDiffuse = gl.getUniformLocation(shaderProgram, 'uUseDiffuse');
            uUseSpecular = gl.getUniformLocation(shaderProgram, 'uUseSpecular');
        }

        // Vector utilities
        function Vector3(x, y, z) { return { x, y, z }; }
        function addVectors(v1, v2) { return Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z); }
        function normalizeVector(v) { 
            const length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z); 
            return Vector3(v.x / length, v.y / length, v.z / length); 
        }

        // Create initial tetrahedron
        function createTetrahedron() {
            const vertices = [
                Vector3(1, 1, 1),
                Vector3(-1, -1, 1),
                Vector3(-1, 1, -1),
                Vector3(1, -1, -1)
            ];

            const normalizedVertices = vertices.map(vertex => normalizeVector(vertex));

            const faces = [
                [0, 1, 2],
                [0, 2, 3],
                [0, 3, 1],
                [1, 3, 2]
            ];

            return { vertices: normalizedVertices, faces: faces };
        }

        // Recursive subdivision function
        function subdivide(vertices, faces, depth) {
            if (depth <= 0) {
                return { vertices, faces };
            }

            const newVertices = [...vertices];
            const newFaces = [];
            const edgeMidpoints = new Map();

            const getMidpoint = (v1, v2) => {
                const edgeKey = `${Math.min(v1, v2)}-${Math.max(v1, v2)}`;
                
                if (edgeMidpoints.has(edgeKey)) {
                    return edgeMidpoints.get(edgeKey);
                }

                const midpoint = normalizeVector(addVectors(vertices[v1], vertices[v2]));
                const index = newVertices.length;
                newVertices.push(midpoint);
                edgeMidpoints.set(edgeKey, index);
                
                return index;
            };

            faces.forEach(face => {
                const [a, b, c] = face;
                const ab = getMidpoint(a, b);
                const bc = getMidpoint(b, c);
                const ca = getMidpoint(c, a);
                
                newFaces.push([a, ab, ca]);
                newFaces.push([b, bc, ab]);
                newFaces.push([c, ca, bc]);
                newFaces.push([ab, bc, ca]);
            });

            return subdivide(newVertices, newFaces, depth - 1);
        }

        // Create sphere using recursive subdivision
        function createSubdivisionSphere(depth) {
            const tetrahedron = createTetrahedron();
            const { vertices, faces } = subdivide(tetrahedron.vertices, tetrahedron.faces, depth);

            const flattenedVertices = [];
            const flattenedNormals = [];
            const indices = [];

            vertices.forEach(vertex => {
                flattenedVertices.push(vertex.x, vertex.y, vertex.z);
                flattenedNormals.push(vertex.x, vertex.y, vertex.z);
            });

            faces.forEach(face => {
                indices.push(face[0], face[1], face[2]);
            });

            return {
                vertices: flattenedVertices,
                normals: flattenedNormals,
                indices: indices
            };
        }

        // Initialize sphere buffers
        function initSphereBuffers() {
            const sphere = createSubdivisionSphere(SUBDIVISION_DEPTH);

            sphereVertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphere.vertices), gl.STATIC_DRAW);

            sphereNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphere.normals), gl.STATIC_DRAW);

            sphereIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphere.indices), gl.STATIC_DRAW);

            indexCount = sphere.indices.length;
        }

        // Matrix utilities
        function multiplyMatrices(a, b) {
            const result = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    let sum = 0;
                    for (let k = 0; k < 4; k++) {
                        sum += a[i * 4 + k] * b[k * 4 + j];
                    }
                    result[i * 4 + j] = sum;
                }
            }
            return result;
        }

        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const rangeInv = 1 / (near - far);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ];
        }

        function createTranslationMatrix(x, y, z) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ];
        }

        function createRotationXMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                1, 0, 0, 0,
                0, c, s, 0,
                0, -s, c, 0,
                0, 0, 0, 1
            ];
        }

        function createRotationYMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return [
                c, 0, -s, 0,
                0, 1, 0, 0,
                s, 0, c, 0,
                0, 0, 0, 1
            ];
        }

        function getNormalMatrix(modelViewMatrix) {
            return [
                modelViewMatrix[0], modelViewMatrix[1], modelViewMatrix[2],
                modelViewMatrix[4], modelViewMatrix[5], modelViewMatrix[6],
                modelViewMatrix[8], modelViewMatrix[9], modelViewMatrix[10]
            ];
        }

        // Color conversion utilities
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            ] : [1, 1, 1];
        }

        // Update light properties from UI
        function updateLightProperties() {
            lightPosition[0] = parseFloat(document.getElementById('light-x').value);
            lightPosition[1] = parseFloat(document.getElementById('light-y').value);
            lightPosition[2] = parseFloat(document.getElementById('light-z').value);

            ambientIntensity = parseFloat(document.getElementById('ambient-intensity').value);
            diffuseCoefficient = parseFloat(document.getElementById('diffuse-coefficient').value);
            specularCoefficient = parseFloat(document.getElementById('specular-coefficient').value);
            shininess = parseFloat(document.getElementById('shininess').value);

            // Update color values
            lightAmbient = hexToRgb(document.getElementById('ambient-color').value);
            lightDiffuse = hexToRgb(document.getElementById('diffuse-color').value);
            lightSpecular = hexToRgb(document.getElementById('specular-color').value);

            // Scale by intensity/coefficients
            lightAmbient = lightAmbient.map(c => c * ambientIntensity);
            lightDiffuse = lightDiffuse.map(c => c * diffuseCoefficient);
            lightSpecular = lightSpecular.map(c => c * specularCoefficient);
        }

        // Draw scene
        function draw() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            updateLightProperties();

            // Projection matrix
            const canvas = document.getElementById('gl-canvas');
            const projectionMatrix = createPerspectiveMatrix(
                45 * Math.PI / 180,
                canvas.width / canvas.height,
                0.1,
                100.0
            );

            // Model-view matrix
            let modelViewMatrix = createTranslationMatrix(0, 0, -cameraDistance);
            modelViewMatrix = multiplyMatrices(modelViewMatrix, createRotationYMatrix(cameraAngleY));
            modelViewMatrix = multiplyMatrices(modelViewMatrix, createRotationXMatrix(cameraAngleX));

            // Normal matrix
            const normalMatrix = getNormalMatrix(modelViewMatrix);

            // Set uniforms
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix3fv(uNormalMatrix, false, normalMatrix);

            // Material properties
            gl.uniform3fv(uMaterialAmbient, materialAmbient);
            gl.uniform3fv(uMaterialDiffuse, materialDiffuse);
            gl.uniform3fv(uMaterialSpecular, materialSpecular);
            gl.uniform1f(uMaterialShininess, shininess);

            // Light properties
            gl.uniform3fv(uLightPosition, lightPosition);
            gl.uniform3fv(uLightAmbient, lightAmbient);
            gl.uniform3fv(uLightDiffuse, lightDiffuse);
            gl.uniform3fv(uLightSpecular, lightSpecular);

            // Lighting toggles
            gl.uniform1i(uUseAmbient, document.getElementById('ambient-toggle').checked);
            gl.uniform1i(uUseDiffuse, document.getElementById('diffuse-toggle').checked);
            gl.uniform1i(uUseSpecular, document.getElementById('specular-toggle').checked);

            // Bind buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexBuffer);
            gl.vertexAttribPointer(shaderProgram.aPosition, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.aNormal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);

            // Draw
            gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
        }

        // Mouse event handlers
        function handleMouseDown(event) {
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }

        function handleMouseMove(event) {
            if (!isDragging) return;
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;
            cameraAngleY += deltaX * 0.01;
            cameraAngleX += deltaY * 0.01;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            draw();
        }

        function handleMouseUp() {
            isDragging = false;
        }

        // Update UI value displays
        function updateValueDisplay(id, value) {
            document.getElementById(id).textContent = value.toFixed(2);
        }

        // Setup UI event listeners
        function setupUIEventListeners() {
            // Light position controls
            const lightX = document.getElementById('light-x');
            const lightY = document.getElementById('light-y');
            const lightZ = document.getElementById('light-z');

            lightX.addEventListener('input', () => updateValueDisplay('light-x-value', parseFloat(lightX.value)));
            lightY.addEventListener('input', () => updateValueDisplay('light-y-value', parseFloat(lightY.value)));
            lightZ.addEventListener('input', () => updateValueDisplay('light-z-value', parseFloat(lightZ.value)));

            // Lighting intensity controls
            const ambientIntensity = document.getElementById('ambient-intensity');
            const diffuseCoefficient = document.getElementById('diffuse-coefficient');
            const specularCoefficient = document.getElementById('specular-coefficient');

            ambientIntensity.addEventListener('input', () => updateValueDisplay('ambient-intensity-value', parseFloat(ambientIntensity.value)));
            diffuseCoefficient.addEventListener('input', () => updateValueDisplay('diffuse-coefficient-value', parseFloat(diffuseCoefficient.value)));
            specularCoefficient.addEventListener('input', () => updateValueDisplay('specular-coefficient-value', parseFloat(specularCoefficient.value)));

            // Shininess control
            const shininess = document.getElementById('shininess');
            shininess.addEventListener('input', () => document.getElementById('shininess-value').textContent = shininess.value);

            // Reset button
            document.getElementById('reset-button').addEventListener('click', () => {
                lightX.value = 2;
                lightY.value = 2;
                lightZ.value = 2;
                updateValueDisplay('light-x-value', 2);
                updateValueDisplay('light-y-value', 2);
                updateValueDisplay('light-z-value', 2);
            });
        }

        // Animation loop
        function animate() {
            // Remove auto-rotation, allow user to control with mouse
            draw();
            requestAnimationFrame(animate);
        }

        // Initialize everything
        function init() {
            initWebGL();
            initShaders();
            initSphereBuffers();

            // Setup event listeners
            const canvas = document.getElementById('gl-canvas');
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);

            setupUIEventListeners();

            // Start animation
            animate();
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>